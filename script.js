var K1="browse-manifest.csv",$1="@@@@@###@@@@@";var U1=(J=0)=>(X)=>`\x1B[${X+J}m`,Y1=(J=0)=>(X)=>`\x1B[${38+J};5;${X}m`,W1=(J=0)=>(X,Z,H)=>`\x1B[${38+J};2;${X};${Z};${H}m`,L={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgGray:[100,49],bgGrey:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}},A0=Object.keys(L.modifier),v1=Object.keys(L.color),b1=Object.keys(L.bgColor),C0=[...v1,...b1];function k1(){let J=new Map;for(let[X,Z]of Object.entries(L)){for(let[H,Q]of Object.entries(Z))L[H]={open:`\x1B[${Q[0]}m`,close:`\x1B[${Q[1]}m`},Z[H]=L[H],J.set(Q[0],Q[1]);Object.defineProperty(L,X,{value:Z,enumerable:!1})}return Object.defineProperty(L,"codes",{value:J,enumerable:!1}),L.color.close="\x1B[39m",L.bgColor.close="\x1B[49m",L.color.ansi=U1(),L.color.ansi256=Y1(),L.color.ansi16m=W1(),L.bgColor.ansi=U1(10),L.bgColor.ansi256=Y1(10),L.bgColor.ansi16m=W1(10),Object.defineProperties(L,{rgbToAnsi256:{value(X,Z,H){if(X===Z&&Z===H){if(X<8)return 16;if(X>248)return 231;return Math.round((X-8)/247*24)+232}return 16+36*Math.round(X/255*5)+6*Math.round(Z/255*5)+Math.round(H/255*5)},enumerable:!1},hexToRgb:{value(X){let Z=/[a-f\d]{6}|[a-f\d]{3}/i.exec(X.toString(16));if(!Z)return[0,0,0];let[H]=Z;if(H.length===3)H=[...H].map((G)=>G+G).join("");let Q=Number.parseInt(H,16);return[Q>>16&255,Q>>8&255,Q&255]},enumerable:!1},hexToAnsi256:{value:(X)=>L.rgbToAnsi256(...L.hexToRgb(X)),enumerable:!1},ansi256ToAnsi:{value(X){if(X<8)return 30+X;if(X<16)return 90+(X-8);let Z,H,Q;if(X>=232)Z=((X-232)*10+8)/255,H=Z,Q=Z;else{X-=16;let $=X%36;Z=Math.floor(X/36)/5,H=Math.floor($/6)/5,Q=$%6/5}let G=Math.max(Z,H,Q)*2;if(G===0)return 30;let K=30+(Math.round(Q)<<2|Math.round(H)<<1|Math.round(Z));if(G===2)K+=60;return K},enumerable:!1},rgbToAnsi:{value:(X,Z,H)=>L.ansi256ToAnsi(L.rgbToAnsi256(X,Z,H)),enumerable:!1},hexToAnsi:{value:(X)=>L.ansi256ToAnsi(L.hexToAnsi256(X)),enumerable:!1}}),L}var x1=k1(),N=x1;var x=(()=>{if(!("navigator"in globalThis))return 0;if(globalThis.navigator.userAgentData){let J=navigator.userAgentData.brands.find(({brand:X})=>X==="Chromium");if(J&&J.version>93)return 3}if(/\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent))return 1;return 0})(),B1=x!==0&&{level:x,hasBasic:!0,has256:x>=2,has16m:x>=3},I1={stdout:B1,stderr:B1},V1=I1;function _1(J,X,Z){let H=J.indexOf(X);if(H===-1)return J;let Q=X.length,G=0,K="";do K+=J.slice(G,H)+X+Z,G=H+Q,H=J.indexOf(X,G);while(H!==-1);return K+=J.slice(G),K}function A1(J,X,Z,H){let Q=0,G="";do{let K=J[H-1]==="\r";G+=J.slice(Q,K?H-1:H)+X+(K?`\r
`:`
`)+Z,Q=H+1,H=J.indexOf(`
`,Q)}while(H!==-1);return G+=J.slice(Q),G}var{stdout:C1,stderr:L1}=V1,l=Symbol("GENERATOR"),T=Symbol("STYLER"),b=Symbol("IS_EMPTY"),R1=["ansi","ansi","ansi256","ansi16m"],M=Object.create(null),f1=(J,X={})=>{if(X.level&&!(Number.isInteger(X.level)&&X.level>=0&&X.level<=3))throw Error("The `level` option should be an integer from 0 to 3");let Z=C1?C1.level:0;J.level=X.level===void 0?Z:X.level};var h1=(J)=>{let X=(...Z)=>Z.join(" ");return f1(X,J),Object.setPrototypeOf(X,k.prototype),X};function k(J){return h1(J)}Object.setPrototypeOf(k.prototype,Function.prototype);for(let[J,X]of Object.entries(N))M[J]={get(){let Z=I(this,n(X.open,X.close,this[T]),this[b]);return Object.defineProperty(this,J,{value:Z}),Z}};M.visible={get(){let J=I(this,this[T],!0);return Object.defineProperty(this,"visible",{value:J}),J}};var d=(J,X,Z,...H)=>{if(J==="rgb"){if(X==="ansi16m")return N[Z].ansi16m(...H);if(X==="ansi256")return N[Z].ansi256(N.rgbToAnsi256(...H));return N[Z].ansi(N.rgbToAnsi(...H))}if(J==="hex")return d("rgb",X,Z,...N.hexToRgb(...H));return N[Z][J](...H)},y1=["rgb","hex","ansi256"];for(let J of y1){M[J]={get(){let{level:Z}=this;return function(...H){let Q=n(d(J,R1[Z],"color",...H),N.color.close,this[T]);return I(this,Q,this[b])}}};let X="bg"+J[0].toUpperCase()+J.slice(1);M[X]={get(){let{level:Z}=this;return function(...H){let Q=n(d(J,R1[Z],"bgColor",...H),N.bgColor.close,this[T]);return I(this,Q,this[b])}}}}var g1=Object.defineProperties(()=>{},{...M,level:{enumerable:!0,get(){return this[l].level},set(J){this[l].level=J}}}),n=(J,X,Z)=>{let H,Q;if(Z===void 0)H=J,Q=X;else H=Z.openAll+J,Q=X+Z.closeAll;return{open:J,close:X,openAll:H,closeAll:Q,parent:Z}},I=(J,X,Z)=>{let H=(...Q)=>p1(H,Q.length===1?""+Q[0]:Q.join(" "));return Object.setPrototypeOf(H,g1),H[l]=J,H[T]=X,H[b]=Z,H},p1=(J,X)=>{if(J.level<=0||!X)return J[b]?"":X;let Z=J[T];if(Z===void 0)return X;let{openAll:H,closeAll:Q}=Z;if(X.includes("\x1B"))while(Z!==void 0)X=_1(X,Z.close,Z.open),Z=Z.parent;let G=X.indexOf(`
`);if(G!==-1)X=A1(X,Q,H,G);return H+X+Q};Object.defineProperties(k.prototype,M);var u1=k(),N0=k({level:L1?L1.level:0});var D=u1;var a={DEBUG:0,INFO:1,WARN:2,ERROR:3,FATAL:4,SIGINT:5},c1={DEBUG:"debug",INFO:" info",WARN:" warn",ERROR:"error",FATAL:"fatal",SIGINT:"sigint"},m1={DEBUG:(J)=>D.gray(J),INFO:(J)=>J,WARN:(J)=>D.yellow(J),ERROR:(J)=>D.red(J),FATAL:(J)=>D.white.bgRed(J),SIGINT:(J)=>D.bgMagenta(J)},f="INFO",w1=a[f],l1={msg:""};class h{get logPrefixes(){return this._logPrefixes}set logPrefixes(J){this._logPrefixes=J}_logPrefixes=[];get logPrefix(){return this._logPrefix}set logPrefix(J){this._logPrefix=J}_logPrefix=null;get messagePaddings(){return this._messagePaddings}set messagePaddings(J){this._messagePaddings=J}_messagePaddings=[];get messagePad(){return this._messagePad}set messagePad(J){this._messagePad=J}_messagePad=null;constructor(...J){this.setLogPrefixes(...J)}static setLogLevel(J){f=J,w1=a[f]}static getLogLevel(){return f}setLogPrefixes=(...J)=>{return this.logPrefixes=[...J],this.logPrefix=J.length===0?null:J.map((X)=>"["+X+"]").join(" "),this};appendLogPrefix=(J)=>{if(this.logPrefixes.push(J),this.logPrefix===null)this.logPrefix="["+J+"]";else this.logPrefix+=" ["+J+"]";return this};addMessagePadding=(J)=>{if(this.messagePaddings.push(J),this.messagePad===null)this.messagePad=J;else this.messagePad+=J;return this};removeAllMessagePadding=()=>{return this.messagePaddings.length=0,this.messagePad=null,this};removeLastMessagePadding=()=>{let J=this.messagePaddings.pop();if(J!==void 0)this.messagePad=this.messagePad.substring(0,this.messagePad.length-J.length);return this};clone(){return new h(...this.logPrefixes)}log=(J,X,...Z)=>{if(a[J]<w1)return;let H=typeof X==="object",Q=H?X.msg:X,G=H?X:l1,K;if(J==="DEBUG"||J==="INFO")K=console.log;else if(J==="WARN")K=console.warn;else if(J==="ERROR"||J==="FATAL")K=console.error;else K=console.log;let $=m1[J],U=Q.split(`
`),Y=D.bold(c1[J])+": "+(this.messagePad===null?"":this.messagePad)+(this.logPrefix===null?"":this.logPrefix+" ");for(let B=0;B<U.length;B++){let W=$(Y+U[B]);K(W)}if(Z.length>0)K(...Z);if(G.data!==void 0){let B=JSON.stringify(G.data,null,4);if(G.stringifyData)K(B);else K(G.data)}if(G.throw)throw Error("see previous message")};logDebug=(J,...X)=>{this.log("DEBUG",J,...X)};logInfo=(J,...X)=>{this.log("INFO",J,...X)};logWarn=(J,...X)=>{this.log("WARN",J,...X)};logError=(J,...X)=>{this.log("ERROR",J,...X)};logFatal=(J,...X)=>{this.log("FATAL",J,...X)};logFatalAndThrow=(J,...X)=>{if(typeof J==="string")this.log("FATAL",{msg:J,throw:!0},...X);else this.log("FATAL",{...J,throw:!0},...X);throw Error("failed to log fatal and throw: should have thrown, not expected to reach this point")}}class p{constructor(J,X){let Z=J._tree,H=Array.from(Z.keys());this.set=J,this._type=X,this._path=H.length>0?[{node:Z,keys:H}]:[]}next(){let J=this.dive();return this.backtrack(),J}dive(){if(this._path.length===0)return{done:!0,value:void 0};let{node:J,keys:X}=S(this._path);if(S(X)==="")return{done:!1,value:this.result()};let Z=J.get(S(X));return this._path.push({node:Z,keys:Array.from(Z.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;let J=S(this._path).keys;if(J.pop(),J.length>0)return;this._path.pop(),this.backtrack()}key(){return this.set._prefix+this._path.map(({keys:J})=>S(J)).filter((J)=>J!=="").join("")}value(){return S(this._path).node.get("")}result(){switch(this._type){case"VALUES":return this.value();case"KEYS":return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}var S=(J)=>{return J[J.length-1]},d1=(J,X,Z)=>{let H=new Map;if(X===void 0)return H;let Q=X.length+1,G=Q+Z,K=new Uint8Array(G*Q).fill(Z+1);for(let $=0;$<Q;++$)K[$]=$;for(let $=1;$<G;++$)K[$*Q]=$;return j1(J,X,Z,H,K,1,Q,""),H},j1=(J,X,Z,H,Q,G,K,$)=>{let U=G*K;J:for(let Y of J.keys())if(Y===""){let B=Q[U-1];if(B<=Z)H.set($,[J.get(Y),B])}else{let B=G;for(let W=0;W<Y.length;++W,++B){let A=Y[W],_=K*B,C=_-K,V=Q[_],R=Math.max(0,B-Z-1),P=Math.min(K-1,B+Z);for(let F=R;F<P;++F){let E=A!==X[F],z=Q[C+F]+ +E,w=Q[C+F+1]+1,O=Q[_+F]+1,m=Q[_+F+1]=Math.min(z,w,O);if(m<V)V=m}if(V>Z)continue J}j1(J.get(Y),X,Z,H,Q,B,K,$+Y)}};class j{constructor(J=new Map,X=""){this._size=void 0,this._tree=J,this._prefix=X}atPrefix(J){if(!J.startsWith(this._prefix))throw Error("Mismatched prefix");let[X,Z]=u(this._tree,J.slice(this._prefix.length));if(X===void 0){let[H,Q]=X1(Z);for(let G of H.keys())if(G!==""&&G.startsWith(Q)){let K=new Map;return K.set(G.slice(Q.length),H.get(G)),new j(K,J)}}return new j(X,J)}clear(){this._size=void 0,this._tree.clear()}delete(J){return this._size=void 0,n1(this._tree,J)}entries(){return new p(this,"ENTRIES")}forEach(J){for(let[X,Z]of this)J(X,Z,this)}fuzzyGet(J,X){return d1(this._tree,J,X)}get(J){let X=t(this._tree,J);return X!==void 0?X.get(""):void 0}has(J){let X=t(this._tree,J);return X!==void 0&&X.has("")}keys(){return new p(this,"KEYS")}set(J,X){if(typeof J!=="string")throw Error("key must be a string");return this._size=void 0,i(this._tree,J).set("",X),this}get size(){if(this._size)return this._size;this._size=0;let J=this.entries();while(!J.next().done)this._size+=1;return this._size}update(J,X){if(typeof J!=="string")throw Error("key must be a string");this._size=void 0;let Z=i(this._tree,J);return Z.set("",X(Z.get(""))),this}fetch(J,X){if(typeof J!=="string")throw Error("key must be a string");this._size=void 0;let Z=i(this._tree,J),H=Z.get("");if(H===void 0)Z.set("",H=X());return H}values(){return new p(this,"VALUES")}[Symbol.iterator](){return this.entries()}static from(J){let X=new j;for(let[Z,H]of J)X.set(Z,H);return X}static fromObject(J){return j.from(Object.entries(J))}}var u=(J,X,Z=[])=>{if(X.length===0||J==null)return[J,Z];for(let H of J.keys())if(H!==""&&X.startsWith(H))return Z.push([J,H]),u(J.get(H),X.slice(H.length),Z);return Z.push([J,X]),u(void 0,"",Z)},t=(J,X)=>{if(X.length===0||J==null)return J;for(let Z of J.keys())if(Z!==""&&X.startsWith(Z))return t(J.get(Z),X.slice(Z.length))},i=(J,X)=>{let Z=X.length;J:for(let H=0;J&&H<Z;){for(let G of J.keys())if(G!==""&&X[H]===G[0]){let K=Math.min(Z-H,G.length),$=1;while($<K&&X[H+$]===G[$])++$;let U=J.get(G);if($===G.length)J=U;else{let Y=new Map;Y.set(G.slice($),U),J.set(X.slice(H,H+$),Y),J.delete(G),J=Y}H+=$;continue J}let Q=new Map;return J.set(X.slice(H),Q),Q}return J},n1=(J,X)=>{let[Z,H]=u(J,X);if(Z===void 0)return;if(Z.delete(""),Z.size===0)E1(H);else if(Z.size===1){let[Q,G]=Z.entries().next().value;O1(H,Q,G)}},E1=(J)=>{if(J.length===0)return;let[X,Z]=X1(J);if(X.delete(Z),X.size===0)E1(J.slice(0,-1));else if(X.size===1){let[H,Q]=X.entries().next().value;if(H!=="")O1(J.slice(0,-1),H,Q)}},O1=(J,X,Z)=>{if(J.length===0)return;let[H,Q]=X1(J);H.set(Q+X,Z),H.delete(Q)},X1=(J)=>{return J[J.length-1]},Z1="or",D1="and",a1="and_not";class q{constructor(J){if((J===null||J===void 0?void 0:J.fields)==null)throw Error('MiniSearch: option "fields" must be provided');let X=J.autoVacuum==null||J.autoVacuum===!0?s:J.autoVacuum;this._options={...o,...J,autoVacuum:X,searchOptions:{...P1,...J.searchOptions||{}},autoSuggestOptions:{...t1,...J.autoSuggestOptions||{}}},this._index=new j,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=J1,this.addFields(this._options.fields)}add(J){let{extractField:X,stringifyField:Z,tokenize:H,processTerm:Q,fields:G,idField:K}=this._options,$=X(J,K);if($==null)throw Error(`MiniSearch: document does not have ID field "${K}"`);if(this._idToShortId.has($))throw Error(`MiniSearch: duplicate ID ${$}`);let U=this.addDocumentId($);this.saveStoredFields(U,J);for(let Y of G){let B=X(J,Y);if(B==null)continue;let W=H(Z(B,Y),Y),A=this._fieldIds[Y],_=new Set(W).size;this.addFieldLength(U,A,this._documentCount-1,_);for(let C of W){let V=Q(C,Y);if(Array.isArray(V))for(let R of V)this.addTerm(A,U,R);else if(V)this.addTerm(A,U,V)}}}addAll(J){for(let X of J)this.add(X)}addAllAsync(J,X={}){let{chunkSize:Z=10}=X,H={chunk:[],promise:Promise.resolve()},{chunk:Q,promise:G}=J.reduce(({chunk:K,promise:$},U,Y)=>{if(K.push(U),(Y+1)%Z===0)return{chunk:[],promise:$.then(()=>new Promise((B)=>setTimeout(B,0))).then(()=>this.addAll(K))};else return{chunk:K,promise:$}},H);return G.then(()=>this.addAll(Q))}remove(J){let{tokenize:X,processTerm:Z,extractField:H,stringifyField:Q,fields:G,idField:K}=this._options,$=H(J,K);if($==null)throw Error(`MiniSearch: document does not have ID field "${K}"`);let U=this._idToShortId.get($);if(U==null)throw Error(`MiniSearch: cannot remove document with ID ${$}: it is not in the index`);for(let Y of G){let B=H(J,Y);if(B==null)continue;let W=X(Q(B,Y),Y),A=this._fieldIds[Y],_=new Set(W).size;this.removeFieldLength(U,A,this._documentCount,_);for(let C of W){let V=Z(C,Y);if(Array.isArray(V))for(let R of V)this.removeTerm(A,U,R);else if(V)this.removeTerm(A,U,V)}}this._storedFields.delete(U),this._documentIds.delete(U),this._idToShortId.delete($),this._fieldLength.delete(U),this._documentCount-=1}removeAll(J){if(J)for(let X of J)this.remove(X);else if(arguments.length>0)throw Error("Expected documents to be present. Omit the argument to remove all documents.");else this._index=new j,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}discard(J){let X=this._idToShortId.get(J);if(X==null)throw Error(`MiniSearch: cannot discard document with ID ${J}: it is not in the index`);this._idToShortId.delete(J),this._documentIds.delete(X),this._storedFields.delete(X),(this._fieldLength.get(X)||[]).forEach((Z,H)=>{this.removeFieldLength(X,H,this._documentCount,Z)}),this._fieldLength.delete(X),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(this._options.autoVacuum===!1)return;let{minDirtFactor:J,minDirtCount:X,batchSize:Z,batchWait:H}=this._options.autoVacuum;this.conditionalVacuum({batchSize:Z,batchWait:H},{minDirtCount:X,minDirtFactor:J})}discardAll(J){let X=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(let Z of J)this.discard(Z)}finally{this._options.autoVacuum=X}this.maybeAutoVacuum()}replace(J){let{idField:X,extractField:Z}=this._options,H=Z(J,X);this.discard(H),this.add(J)}vacuum(J={}){return this.conditionalVacuum(J)}conditionalVacuum(J,X){if(this._currentVacuum){if(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&X,this._enqueuedVacuum!=null)return this._enqueuedVacuum;return this._enqueuedVacuum=this._currentVacuum.then(()=>{let Z=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=J1,this.performVacuuming(J,Z)}),this._enqueuedVacuum}if(this.vacuumConditionsMet(X)===!1)return Promise.resolve();return this._currentVacuum=this.performVacuuming(J),this._currentVacuum}async performVacuuming(J,X){let Z=this._dirtCount;if(this.vacuumConditionsMet(X)){let H=J.batchSize||e.batchSize,Q=J.batchWait||e.batchWait,G=1;for(let[K,$]of this._index){for(let[U,Y]of $)for(let[B]of Y){if(this._documentIds.has(B))continue;if(Y.size<=1)$.delete(U);else Y.delete(B)}if(this._index.get(K).size===0)this._index.delete(K);if(G%H===0)await new Promise((U)=>setTimeout(U,Q));G+=1}this._dirtCount-=Z}await null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}vacuumConditionsMet(J){if(J==null)return!0;let{minDirtCount:X,minDirtFactor:Z}=J;return X=X||s.minDirtCount,Z=Z||s.minDirtFactor,this.dirtCount>=X&&this.dirtFactor>=Z}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(J){return this._idToShortId.has(J)}getStoredFields(J){let X=this._idToShortId.get(J);if(X==null)return;return this._storedFields.get(X)}search(J,X={}){let{searchOptions:Z}=this._options,H={...Z,...X},Q=this.executeQuery(J,X),G=[];for(let[K,{score:$,terms:U,match:Y}]of Q){let B=U.length||1,W={id:this._documentIds.get(K),score:$*B,terms:Object.keys(Y),queryTerms:U,match:Y};if(Object.assign(W,this._storedFields.get(K)),H.filter==null||H.filter(W))G.push(W)}if(J===q.wildcard&&H.boostDocument==null)return G;return G.sort(F1),G}autoSuggest(J,X={}){X={...this._options.autoSuggestOptions,...X};let Z=new Map;for(let{score:Q,terms:G}of this.search(J,X)){let K=G.join(" "),$=Z.get(K);if($!=null)$.score+=Q,$.count+=1;else Z.set(K,{score:Q,terms:G,count:1})}let H=[];for(let[Q,{score:G,terms:K,count:$}]of Z)H.push({suggestion:Q,terms:K,score:G/$});return H.sort(F1),H}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(J,X){if(X==null)throw Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(J),X)}static async loadJSONAsync(J,X){if(X==null)throw Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(J),X)}static getDefault(J){if(o.hasOwnProperty(J))return r(o,J);else throw Error(`MiniSearch: unknown option "${J}"`)}static loadJS(J,X){let{index:Z,documentIds:H,fieldLength:Q,storedFields:G,serializationVersion:K}=J,$=this.instantiateMiniSearch(J,X);$._documentIds=y(H),$._fieldLength=y(Q),$._storedFields=y(G);for(let[U,Y]of $._documentIds)$._idToShortId.set(Y,U);for(let[U,Y]of Z){let B=new Map;for(let W of Object.keys(Y)){let A=Y[W];if(K===1)A=A.ds;B.set(parseInt(W,10),y(A))}$._index.set(U,B)}return $}static async loadJSAsync(J,X){let{index:Z,documentIds:H,fieldLength:Q,storedFields:G,serializationVersion:K}=J,$=this.instantiateMiniSearch(J,X);$._documentIds=await g(H),$._fieldLength=await g(Q),$._storedFields=await g(G);for(let[Y,B]of $._documentIds)$._idToShortId.set(B,Y);let U=0;for(let[Y,B]of Z){let W=new Map;for(let A of Object.keys(B)){let _=B[A];if(K===1)_=_.ds;W.set(parseInt(A,10),await g(_))}if(++U%1000===0)await q1(0);$._index.set(Y,W)}return $}static instantiateMiniSearch(J,X){let{documentCount:Z,nextId:H,fieldIds:Q,averageFieldLength:G,dirtCount:K,serializationVersion:$}=J;if($!==1&&$!==2)throw Error("MiniSearch: cannot deserialize an index created with an incompatible version");let U=new q(X);return U._documentCount=Z,U._nextId=H,U._idToShortId=new Map,U._fieldIds=Q,U._avgFieldLength=G,U._dirtCount=K||0,U._index=new j,U}executeQuery(J,X={}){if(J===q.wildcard)return this.executeWildcardQuery(X);if(typeof J!=="string"){let W={...X,...J,queries:void 0},A=J.queries.map((_)=>this.executeQuery(_,W));return this.combineResults(A,W.combineWith)}let{tokenize:Z,processTerm:H,searchOptions:Q}=this._options,G={tokenize:Z,processTerm:H,...Q,...X},{tokenize:K,processTerm:$}=G,B=K(J).flatMap((W)=>$(W)).filter((W)=>!!W).map(s1(G)).map((W)=>this.executeQuerySpec(W,G));return this.combineResults(B,G.combineWith)}executeQuerySpec(J,X){let Z={...this._options.searchOptions,...X},H=(Z.fields||this._options.fields).reduce((C,V)=>({...C,[V]:r(Z.boost,V)||1}),{}),{boostDocument:Q,weights:G,maxFuzzy:K,bm25:$}=Z,{fuzzy:U,prefix:Y}={...P1.weights,...G},B=this._index.get(J.term),W=this.termResults(J.term,J.term,1,J.termBoost,B,H,Q,$),A,_;if(J.prefix)A=this._index.atPrefix(J.term);if(J.fuzzy){let C=J.fuzzy===!0?0.2:J.fuzzy,V=C<1?Math.min(K,Math.round(J.term.length*C)):C;if(V)_=this._index.fuzzyGet(J.term,V)}if(A)for(let[C,V]of A){let R=C.length-J.term.length;if(!R)continue;_===null||_===void 0||_.delete(C);let P=Y*C.length/(C.length+0.3*R);this.termResults(J.term,C,P,J.termBoost,V,H,Q,$,W)}if(_)for(let C of _.keys()){let[V,R]=_.get(C);if(!R)continue;let P=U*C.length/(C.length+R);this.termResults(J.term,C,P,J.termBoost,V,H,Q,$,W)}return W}executeWildcardQuery(J){let X=new Map,Z={...this._options.searchOptions,...J};for(let[H,Q]of this._documentIds){let G=Z.boostDocument?Z.boostDocument(Q,"",this._storedFields.get(H)):1;X.set(H,{score:G,terms:[],match:{}})}return X}combineResults(J,X=Z1){if(J.length===0)return new Map;let Z=X.toLowerCase(),H=i1[Z];if(!H)throw Error(`Invalid combination operator: ${X}`);return J.reduce(H)||new Map}toJSON(){let J=[];for(let[X,Z]of this._index){let H={};for(let[Q,G]of Z)H[Q]=Object.fromEntries(G);J.push([X,H])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:J,serializationVersion:2}}termResults(J,X,Z,H,Q,G,K,$,U=new Map){if(Q==null)return U;for(let Y of Object.keys(G)){let B=G[Y],W=this._fieldIds[Y],A=Q.get(W);if(A==null)continue;let _=A.size,C=this._avgFieldLength[W];for(let V of A.keys()){if(!this._documentIds.has(V)){this.removeTerm(W,V,X),_-=1;continue}let R=K?K(this._documentIds.get(V),X,this._storedFields.get(V)):1;if(!R)continue;let P=A.get(V),F=this._fieldLength.get(V)[W],E=o1(P,_,this._documentCount,F,C,$),z=Z*H*B*R*E,w=U.get(V);if(w){w.score+=z,e1(w.terms,J);let O=r(w.match,X);if(O)O.push(Y);else w.match[X]=[Y]}else U.set(V,{score:z,terms:[J],match:{[X]:[Y]}})}}return U}addTerm(J,X,Z){let H=this._index.fetch(Z,N1),Q=H.get(J);if(Q==null)Q=new Map,Q.set(X,1),H.set(J,Q);else{let G=Q.get(X);Q.set(X,(G||0)+1)}}removeTerm(J,X,Z){if(!this._index.has(Z)){this.warnDocumentChanged(X,J,Z);return}let H=this._index.fetch(Z,N1),Q=H.get(J);if(Q==null||Q.get(X)==null)this.warnDocumentChanged(X,J,Z);else if(Q.get(X)<=1)if(Q.size<=1)H.delete(J);else Q.delete(X);else Q.set(X,Q.get(X)-1);if(this._index.get(Z).size===0)this._index.delete(Z)}warnDocumentChanged(J,X,Z){for(let H of Object.keys(this._fieldIds))if(this._fieldIds[H]===X){this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(J)} has changed before removal: term "${Z}" was not present in field "${H}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}}addDocumentId(J){let X=this._nextId;return this._idToShortId.set(J,X),this._documentIds.set(X,J),this._documentCount+=1,this._nextId+=1,X}addFields(J){for(let X=0;X<J.length;X++)this._fieldIds[J[X]]=X}addFieldLength(J,X,Z,H){let Q=this._fieldLength.get(J);if(Q==null)this._fieldLength.set(J,Q=[]);Q[X]=H;let K=(this._avgFieldLength[X]||0)*Z+H;this._avgFieldLength[X]=K/(Z+1)}removeFieldLength(J,X,Z,H){if(Z===1){this._avgFieldLength[X]=0;return}let Q=this._avgFieldLength[X]*Z-H;this._avgFieldLength[X]=Q/(Z-1)}saveStoredFields(J,X){let{storeFields:Z,extractField:H}=this._options;if(Z==null||Z.length===0)return;let Q=this._storedFields.get(J);if(Q==null)this._storedFields.set(J,Q={});for(let G of Z){let K=H(X,G);if(K!==void 0)Q[G]=K}}}q.wildcard=Symbol("*");var r=(J,X)=>Object.prototype.hasOwnProperty.call(J,X)?J[X]:void 0,i1={[Z1]:(J,X)=>{for(let Z of X.keys()){let H=J.get(Z);if(H==null)J.set(Z,X.get(Z));else{let{score:Q,terms:G,match:K}=X.get(Z);H.score=H.score+Q,H.match=Object.assign(H.match,K),z1(H.terms,G)}}return J},[D1]:(J,X)=>{let Z=new Map;for(let H of X.keys()){let Q=J.get(H);if(Q==null)continue;let{score:G,terms:K,match:$}=X.get(H);z1(Q.terms,K),Z.set(H,{score:Q.score+G,terms:Q.terms,match:Object.assign(Q.match,$)})}return Z},[a1]:(J,X)=>{for(let Z of X.keys())J.delete(Z);return J}},r1={k:1.2,b:0.7,d:0.5},o1=(J,X,Z,H,Q,G)=>{let{k:K,b:$,d:U}=G;return Math.log(1+(Z-X+0.5)/(X+0.5))*(U+J*(K+1)/(J+K*(1-$+$*H/Q)))},s1=(J)=>(X,Z,H)=>{let Q=typeof J.fuzzy==="function"?J.fuzzy(X,Z,H):J.fuzzy||!1,G=typeof J.prefix==="function"?J.prefix(X,Z,H):J.prefix===!0,K=typeof J.boostTerm==="function"?J.boostTerm(X,Z,H):1;return{term:X,fuzzy:Q,prefix:G,termBoost:K}},o={idField:"id",extractField:(J,X)=>J[X],stringifyField:(J,X)=>J.toString(),tokenize:(J)=>J.split(J0),processTerm:(J)=>J.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(J,X)=>{if(typeof(console===null||console===void 0?void 0:console[J])==="function")console[J](X)},autoVacuum:!0},P1={combineWith:Z1,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:0.45,prefix:0.375},bm25:r1},t1={combineWith:D1,prefix:(J,X,Z)=>X===Z.length-1},e={batchSize:1000,batchWait:10},J1={minDirtFactor:0.1,minDirtCount:20},s={...e,...J1},e1=(J,X)=>{if(!J.includes(X))J.push(X)},z1=(J,X)=>{for(let Z of X)if(!J.includes(Z))J.push(Z)},F1=({score:J},{score:X})=>X-J,N1=()=>new Map,y=(J)=>{let X=new Map;for(let Z of Object.keys(J))X.set(parseInt(Z,10),J[Z]);return X},g=async(J)=>{let X=new Map,Z=0;for(let H of Object.keys(J))if(X.set(parseInt(H,10),J[H]),++Z%1000===0)await q1(0);return X},q1=(J)=>new Promise((X)=>setTimeout(X,J)),J0=/[\n\r\p{Z}\p{P}]+/u;var X0=Object.prototype.toString,Z0=(J)=>X0.call(J)==="[object Error]",H0=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function H1(J){if(!(J&&Z0(J)&&J.name==="TypeError"&&typeof J.message==="string"))return!1;let{message:Z,stack:H}=J;if(Z==="Load failed")return H===void 0||"__sentry_captured__"in J;if(Z.startsWith("error sending request for url"))return!0;return H0.has(Z)}function Q0(J){if(typeof J==="number"){if(J<0)throw TypeError("Expected `retries` to be a non-negative number.");if(Number.isNaN(J))throw TypeError("Expected `retries` to be a valid number or Infinity, got NaN.")}else if(J!==void 0)throw TypeError("Expected `retries` to be a number or Infinity.")}function c(J,X,{min:Z=0,allowInfinity:H=!1}={}){if(X===void 0)return;if(typeof X!=="number"||Number.isNaN(X))throw TypeError(`Expected \`${J}\` to be a number${H?" or Infinity":""}.`);if(!H&&!Number.isFinite(X))throw TypeError(`Expected \`${J}\` to be a finite number.`);if(X<Z)throw TypeError(`Expected \`${J}\` to be â‰¥ ${Z}.`)}class M1 extends Error{constructor(J){super();if(J instanceof Error)this.originalError=J,{message:J}=J;else this.originalError=Error(J),this.originalError.stack=this.stack;this.name="AbortError",this.message=J}}function G0(J,X){let Z=Math.max(1,J+1),H=X.randomize?Math.random()+1:1,Q=Math.round(H*X.minTimeout*X.factor**(Z-1));return Q=Math.min(Q,X.maxTimeout),Q}function T1(J,X){if(!Number.isFinite(X))return X;return X-(performance.now()-J)}async function K0({error:J,attemptNumber:X,retriesConsumed:Z,startTime:H,options:Q}){let G=J instanceof Error?J:TypeError(`Non-error was thrown: "${J}". You should only throw errors.`);if(G instanceof M1)throw G.originalError;let K=Number.isFinite(Q.retries)?Math.max(0,Q.retries-Z):Q.retries,$=Q.maxRetryTime??Number.POSITIVE_INFINITY,U=Object.freeze({error:G,attemptNumber:X,retriesLeft:K,retriesConsumed:Z});if(await Q.onFailedAttempt(U),T1(H,$)<=0)throw G;let Y=await Q.shouldConsumeRetry(U),B=T1(H,$);if(B<=0||K<=0)throw G;if(G instanceof TypeError&&!H1(G)){if(Y)throw G;return Q.signal?.throwIfAborted(),!1}if(!await Q.shouldRetry(U))throw G;if(!Y)return Q.signal?.throwIfAborted(),!1;let W=G0(Z,Q),A=Math.min(W,B);if(Q.signal?.throwIfAborted(),A>0)await new Promise((_,C)=>{let V=()=>{clearTimeout(R),Q.signal?.removeEventListener("abort",V),C(Q.signal.reason)},R=setTimeout(()=>{Q.signal?.removeEventListener("abort",V),_()},A);if(Q.unref)R.unref?.();Q.signal?.addEventListener("abort",V,{once:!0})});return Q.signal?.throwIfAborted(),!0}async function Q1(J,X={}){if(X={...X},Q0(X.retries),Object.hasOwn(X,"forever"))throw Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");if(X.retries??=10,X.factor??=2,X.minTimeout??=1000,X.maxTimeout??=Number.POSITIVE_INFINITY,X.maxRetryTime??=Number.POSITIVE_INFINITY,X.randomize??=!1,X.onFailedAttempt??=()=>{},X.shouldRetry??=()=>!0,X.shouldConsumeRetry??=()=>!0,c("factor",X.factor,{min:0,allowInfinity:!1}),c("minTimeout",X.minTimeout,{min:0,allowInfinity:!1}),c("maxTimeout",X.maxTimeout,{min:0,allowInfinity:!0}),c("maxRetryTime",X.maxRetryTime,{min:0,allowInfinity:!0}),!(X.factor>0))X.factor=1;X.signal?.throwIfAborted();let Z=0,H=0,Q=performance.now();while(Number.isFinite(X.retries)?H<=X.retries:!0){Z++;try{X.signal?.throwIfAborted();let G=await J(Z);return X.signal?.throwIfAborted(),G}catch(G){if(await K0({error:G,attemptNumber:Z,retriesConsumed:H,startTime:Q,options:X}))H++}}throw Error("Retry attempts exhausted without throwing an error.")}function S1(J,X,Z,H){return J.slice(0,X)+H+J.slice(Z)}var{logError:G1}=new h,$0=15,U0="/"+K1,v=await Y0();W0();B0();V0();async function Y0(){let J=await Q1(async()=>{let H;try{H=await fetch(U0).then((Q)=>Q.text())}catch(Q){G1({msg:"failed to load manifest; scheduling retry",data:Q});return}return H},{maxTimeout:1e4});if(!J)return null;let X=!0,Z=J.split(`
`).map((H)=>{let Q=H.split($1);if(Q.length!==2)X=!1;return{pageTitle:Q[0]??"",pageUrl:Q[1]??""}});if(!X)return G1({msg:"failed to parse manifest",data:{error:"invalid format",manifest:Z}}),null;return Z}function W0(){let J=document.querySelector("input#searchInput");if(!J||!v)return;let X=J.parentElement,Z=["pageTitle","pageUrl"],H=new q({fields:Z,storeFields:Z}),Q=v.map((W)=>({id:W.pageUrl,...W}));H.addAll(Q);let G=[];J.classList.add("search-input");let K=document.createElement("div");K.classList.add("search-suggest","hidden"),document.body.append(K),J.addEventListener("input",(W)=>B(J.value)),X.addEventListener("submit",(W)=>{if(W.preventDefault(),G.length>0)window.location.href=G[0].pageUrl;return!1});function $(){let W=J.getBoundingClientRect();K.style.top=window.scrollY+W.top+W.height+"px",K.style.left=window.scrollX+W.left+"px"}function U(){K.classList.remove("hidden")}function Y(){K.classList.add("hidden")}function B(W){$();let A=H.search(W,{fuzzy:!0});if(G=A,K.innerHTML="",A.length===0){let _=document.createElement("span");_.classList.add("suggest-no-matches"),_.innerText="no matches",K.append(_)}for(let _=0;_<Math.min($0,A.length);_++){let C=A[_],V=C.pageTitle;if(typeof V!=="string"){G1({msg:"failed to extract page title from a search match",data:{match:C}});return}let R=V.toLocaleLowerCase(),P=document.createElement("a");P.tabIndex=_+1,P.classList.add("suggest-item"),P.href=C.pageUrl;let F=C.terms.map((z)=>{let w=R.indexOf(z),O=w+z.length;return{term:V.substring(w,O),start:w,end:O}}).sort((z,w)=>w.end-z.end),E=V;for(let z of F){let w=`<span class='suggest-hl'>${z.term}</span>`;E=S1(E,z.start,z.end,w)}P.innerHTML=E,K.append(P)}U()}}function B0(){let J=document.querySelector("#n-randompage > a");if(!J)return;J.href="javascript:void(0)";let X=()=>{if(!v||v.length===0)return;let H=v[Z(v)];J.href=H.pageUrl,J.removeEventListener("click",X),J.click()};J.addEventListener("click",X);function Z(H){return H.length===0?-1:Math.floor(Math.random()*H.length)}}function V0(){if(localStorage.getItem("disclaimer-state"))return;let X=`<b>DISCLAIMER:</b> This is a <b>readonly</b> copy of the X3 Wiki scrapped from Wayback Machine. Preserve \uD83E\uDDE1 Enjoy!<br><a href="https://github.com/murolem/x3-wiki-archive"><b>Project page</b></a>
<button class="remove">
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
    <!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
    <svg width="800px" height="800px" viewBox="0 0 25 25" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
        
        <title>cross</title>
        <desc>Created with Sketch Beta.</desc>
        <defs>

    </defs>
        <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">
            <g id="Icon-Set-Filled" sketch:type="MSLayerGroup" transform="translate(-469.000000, -1041.000000)" fill="#000000">
                <path d="M487.148,1053.48 L492.813,1047.82 C494.376,1046.26 494.376,1043.72 492.813,1042.16 C491.248,1040.59 488.712,1040.59 487.148,1042.16 L481.484,1047.82 L475.82,1042.16 C474.257,1040.59 471.721,1040.59 470.156,1042.16 C468.593,1043.72 468.593,1046.26 470.156,1047.82 L475.82,1053.48 L470.156,1059.15 C468.593,1060.71 468.593,1063.25 470.156,1064.81 C471.721,1066.38 474.257,1066.38 475.82,1064.81 L481.484,1059.15 L487.148,1064.81 C488.712,1066.38 491.248,1066.38 492.813,1064.81 C494.376,1063.25 494.376,1060.71 492.813,1059.15 L487.148,1053.48" id="cross" sketch:type="MSShapeGroup">

    </path>
            </g>
        </g>
    </svg>
</button>
`,Z=document.createElement("div");Z.classList.add("wiki-disclaimer-i-love-furries","fade-in"),Z.innerHTML=X;let H=Z.querySelector("button.remove");if(!H)return;H.addEventListener("click",()=>{Z.classList.add("fade-out"),setTimeout(()=>Z.remove(),400),localStorage.setItem("disclaimer-state",":3")}),document.body.append(Z),setTimeout(()=>Z.classList.remove("fade-in"),2000)}
